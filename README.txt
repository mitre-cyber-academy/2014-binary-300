Name: Format String Exploit

Description: User is told to select door, however they cannot just type in numbers. The user must use format strings to redirect program flow to many various functions that start with 'door'. If they disassemble the code they will see there are no door functions called. The user will have to look at the object dumps to find the addresses of the functions and use the dynamic relocation table to overwrite the address of exit function (_exit is a different function but does the same thing). The key can be found by either just guessing, or by following the clues each door gives.

Solution: The solution for this challenge will vary from machine to machine due to memory addresses. It is HIGHLY recommended that if you want to solve this with some ease, you should turn of randomize_va_space. You can do this by navigating to /proc/sys/kernel and doing # echo 0 > randomize_va_space  . Then you must find the address of the exit function by doing # objdump -R format | grep exit  . Once found, you can find all the addresses to the functions by doing objdump -t format. To make it easier to find the door functions add 
| grep door to the end of the function to list all the door functions. Now that the user has these, they must now find where the stack begins. This is done by using brute force. E.g. python -c 'print "AAAA" + "%x." * 150' | ./format  . Once you find the position of the stack and the addresses, you can now exploit the program. The next part can be difficult for people new to format strings. We will need to overwrite addresses using the format string. This is done by overwriting one or two bytes at a time and calculating byte offsets. Here's an example: Say the address for exit is at 0804a020 and the flag is at 08048683. We must remember that intel does things in little endian. So here we go...
python -c 'print "\x20\xa0\x04\x08" + "\x21\xa0\x04\x08" + "\x23\xa0\x04\x08" + "%119x%4$hn" + "%1027x%5$hn" + "%130x%6$hn"' | ./format

So here we are using place holders for hex, bytes and writing. We are writing "83" (decimal 131) to address ending in 20, "486" (decimal 1158) for 21 (this one writes to 2 bytes), "508" for 23 (decimal 1288). Using the %hn will write the number of bytes seen up until the %n and the $4, $5, $6 are places on the stack. 83 and 508 will write 0x83 and 0x08 to their respective places. This is because we are only writing to one byte position. Meanwhile we are going to write 484 as 0x04 and 0x84. This will write to addresses ending in 21 and 22 respectively. Once entered, the program flow will be redirected and the key (in this case) will be shown.

Calculating byte offsets: The easiest way to do this is to use a hex to decimal converter. Hex 83 translates to 131 in decimal and the rest is seen as above. As you can see we used "%119x%4$hn" we had to account for the previous 12 bytes seen. 119 + 12 = 131, which is what we need. The same will have to be accounted for the previous bytes encountered.

To compile: gcc -Wall -m32 -fno-stack-protector format.c -o doors